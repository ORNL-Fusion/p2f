<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>p2f: idl/test_particle_size.pro Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.9 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Modules</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_9b564d76ac44037fc45a94b78ae21028.html">idl</a>
  </div>
</div>
<div class="contents">
<h1>test_particle_size.pro</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 pro test_particle_size
<a name="l00002"></a>00002 
<a name="l00003"></a>00003 amu = 2d0
<a name="l00004"></a>00004 mi  = amu * 1.672615d-27
<a name="l00005"></a>00005 e_  = 1.602176d-19
<a name="l00006"></a>00006 c   = 3.0d+08
<a name="l00007"></a>00007 vParRange   = 3.0d-2 * c
<a name="l00008"></a>00008 vPerRange   = 3.0d-2 * c
<a name="l00009"></a>00009 sigma   = 2.0 * 1d-04 * c
<a name="l00010"></a>00010 nPar    = 128 
<a name="l00011"></a>00011 nPer    = 128 
<a name="l00012"></a>00012 nPhi    = 21  
<a name="l00013"></a>00013 density = 1.0e19
<a name="l00014"></a>00014 
<a name="l00015"></a>00015 suggestedSigma  = sqrt ( vPerRange^2/700.0 ) 
<a name="l00016"></a>00016 
<a name="l00017"></a>00017 particle_keV    = sigma^2 * 0.5 * mi / e_ / 1d3
<a name="l00018"></a>00018 sugg_particle_keV   = suggestedSigma^2 * 0.5 * mi / e_ / 1d3
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 maxRange_keV    = ( vParRange^2 + vPerRange^2 ) * 0.5 * mi / e_ / 1d3
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 print, 'sigma: ', sigma / c *1d4
<a name="l00023"></a>00023 print, 'suggested sigma: ', suggestedSigma / c * 1d4
<a name="l00024"></a>00024 print, 'particle size in keV: ', particle_keV
<a name="l00025"></a>00025 print, 'suggested particle size in keV: ', sugg_particle_keV
<a name="l00026"></a>00026 print, 'max energy range [keV]: ', maxRange_keV 
<a name="l00027"></a>00027 print, 'per energy range [keV]: ', ( vPerRange^2 ) * 0.5 * mi / e_ / 1d3
<a name="l00028"></a>00028 print, 'par energy range [keV]: ', ( vParRange^2 ) * 0.5 * mi / e_ / 1d3
<a name="l00029"></a>00029 stop
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 ;   Build in cylindrical 
<a name="l00032"></a>00032 
<a name="l00033"></a>00033 vPar    = transpose ( rebin ( (dIndGen ( nPar + 1 )- nPar / 2d0) / (nPar/2d0) $
<a name="l00034"></a>00034     * vParRange, nPar+1, nPer, nPhi ), [1,0,2] )
<a name="l00035"></a>00035 vPer    = rebin ( dIndGen ( nPer ) / nPer * vPerRange, nPer, nPar+1, nPhi ) 
<a name="l00036"></a>00036 phi     = transpose ( rebin ( dIndGen ( nPhi ) / (nPhi-1) * (2d0*!dpi), nPhi, nPer, nPar+1 ), [1,2,0] )
<a name="l00037"></a>00037 
<a name="l00038"></a>00038 vX_ = vPer * cos ( phi )
<a name="l00039"></a>00039 vY_ = vPer * sin ( phi )
<a name="l00040"></a>00040 vZ_ = vPar
<a name="l00041"></a>00041 
<a name="l00042"></a>00042 uPar    = 0d0*c
<a name="l00043"></a>00043 uPer    = 0d0*c
<a name="l00044"></a>00044 uPhi    = 0d0
<a name="l00045"></a>00045 uPer2   = 0.004*c
<a name="l00046"></a>00046 
<a name="l00047"></a>00047 uX_ = uPer * cos ( uPhi )
<a name="l00048"></a>00048 uY_ = uPer * sin ( uPhi )
<a name="l00049"></a>00049 uX_2    = uPer2 * cos ( uPhi )
<a name="l00050"></a>00050 uY_2    = uPer2 * sin ( uPhi )
<a name="l00051"></a>00051 
<a name="l00052"></a>00052 uZ_ = uPar
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 uX  = 0d0*c
<a name="l00055"></a>00055 uY  = 0.025d0*c
<a name="l00056"></a>00056 uZ  = 0.000d0*c
<a name="l00057"></a>00057 uY2 = 0.025d0*c
<a name="l00058"></a>00058 
<a name="l00059"></a>00059 f_rpz   = density / ( ( 2.0 * !pi ) ^ 3.0/2.0 * sigma^3 ) $
<a name="l00060"></a>00060     * exp ( -1.0 * ( ( vX_ - uX )^2 / ( 2.0 * sigma^2 ) + $
<a name="l00061"></a>00061                         ( vY_ - uY )^2 / ( 2.0 * sigma^2 ) + $
<a name="l00062"></a>00062                         ( vZ_ - uZ )^2 / ( 2.0 * sigma^2 ) ) ) 
<a name="l00063"></a>00063 f_rpz2  = density / ( ( 2.0 * !pi ) ^ 3.0/2.0 * sigma^3 ) $
<a name="l00064"></a>00064     * exp ( -1.0 * ( ( vX_ - uX )^2 / ( 2.0 * sigma^2 ) + $
<a name="l00065"></a>00065                         ( vY_ - uY2 )^2 / ( 2.0 * sigma^2 ) + $
<a name="l00066"></a>00066                         ( vZ_ - uZ )^2 / ( 2.0 * sigma^2 ) ) ) 
<a name="l00067"></a>00067 
<a name="l00068"></a>00068 
<a name="l00069"></a>00069 dPhi    = abs ( phi[0,0,0] - phi[0,0,1] )
<a name="l00070"></a>00070 dvPar   = abs ( vPar[0,0,0] - vPar[0,1,0] )
<a name="l00071"></a>00071 dvPer   = abs ( vPer[0,0,0] - vPer[1,0,0] )
<a name="l00072"></a>00072 
<a name="l00073"></a>00073 restore, '~/data/particleLists/fdis_25keV_D_4_flat_D3D.sav'
<a name="l00074"></a>00074 
<a name="l00075"></a>00075 f_rpz_int   = fltArr ( size ( f_rpz, /dim ) )
<a name="l00076"></a>00076 f_rpz_int2  = fltArr ( size ( f_rpz, /dim ) )
<a name="l00077"></a>00077 f_rpz_int3  = fltArr ( size ( f_rpz, /dim ) )
<a name="l00078"></a>00078 f_vv_int    = fltArr ( nPer, nPar+1) 
<a name="l00079"></a>00079 
<a name="l00080"></a>00080 for i = 0, 100-1 do begin
<a name="l00081"></a>00081 
<a name="l00082"></a>00082     uPar_p  =0.0; p.vPar[i]
<a name="l00083"></a>00083     uPer_p  = p.vPerp[i]*2 
<a name="l00084"></a>00084     uPhi_p  = 0.0
<a name="l00085"></a>00085     uPhi_p2 = !pi/2d0
<a name="l00086"></a>00086 
<a name="l00087"></a>00087     print, i, uper_p, upar_p
<a name="l00088"></a>00088 
<a name="l00089"></a>00089     parii   = ( uPar_p - min ( vpar[0,*,0] ) ) / (vParRange * 2.0) * nPar
<a name="l00090"></a>00090     perii   = uPer_p / vPerRange * nPer
<a name="l00091"></a>00091     
<a name="l00092"></a>00092     if parii lt npar and perii lt nper and parii ge 0 then $
<a name="l00093"></a>00093         ++f_rpz_int3[perii,parii,0] 
<a name="l00094"></a>00094 
<a name="l00095"></a>00095     uXX = uPer_p * cos ( uPhi_p )
<a name="l00096"></a>00096     uYY = uPer_p * sin ( uPhi_p )
<a name="l00097"></a>00097 
<a name="l00098"></a>00098     uXX2    = uPer_p * cos ( uPhi_p2 )
<a name="l00099"></a>00099     uYY2    = uPer_p * sin ( uPhi_p2 )
<a name="l00100"></a>00100     
<a name="l00101"></a>00101     uZZ = uPar_p
<a name="l00102"></a>00102     
<a name="l00103"></a>00103     f_rpz_tmp   = density / ( ( 2.0 * !pi ) ^ 3.0/2.0 * sigma^3 ) $
<a name="l00104"></a>00104     * exp ( -1.0 * ( ( vX_ - uXX )^2 / ( 2.0 * sigma^2 ) + $
<a name="l00105"></a>00105                         ( vY_ - uYY )^2 / ( 2.0 * sigma^2 ) + $
<a name="l00106"></a>00106                         ( vZ_ - uZZ )^2 / ( 2.0 * sigma^2 ) ) ) 
<a name="l00107"></a>00107     f_rpz_tmp2  = density / ( ( 2.0 * !pi ) ^ 3.0/2.0 * sigma^3 ) $
<a name="l00108"></a>00108     * exp ( -1.0 * ( ( vX_ - uXX2 )^2 / ( 2.0 * sigma^2 ) + $
<a name="l00109"></a>00109                         ( vY_ - uYY2 )^2 / ( 2.0 * sigma^2 ) + $
<a name="l00110"></a>00110                         ( vZ_ - uZZ )^2 / ( 2.0 * sigma^2 ) ) ) 
<a name="l00111"></a>00111     
<a name="l00112"></a>00112     f_vv_tmp    = density / ( ( 2.0 * !pi ) ^ 3.0/2.0 * sigma^3 ) $
<a name="l00113"></a>00113     * exp ( ( -uPer_p^2 - (uPar_p-vPar[*,*,0])^2-vPer[*,*,0]^2 ) / ( 2.0 * sigma^2 ) ) $
<a name="l00114"></a>00114                          * 2.0 * !pi * beselI (  (uPer_p * vPer[*,*,0]/sigma^2)&lt;700, 0.0, /<span class="keywordtype">double</span> )
<a name="l00115"></a>00115 
<a name="l00116"></a>00116     ;   Try adaptive phi integral range
<a name="l00117"></a>00117     
<a name="l00118"></a>00118     phiR    = 2.5 * sigma / uPer_p
<a name="l00119"></a>00119     phi_    = ( fIndGen ( nPhi ) - nPhi / 2 ) / ( nPhi / 2 ) * phiR
<a name="l00120"></a>00120     phi_    = transpose ( rebin ( phi_, nPhi, nPer, nPar + 1 ), [1,2,0] )
<a name="l00121"></a>00121     vX__    = vPer * cos ( phi_ )
<a name="l00122"></a>00122     vY__    = vPer * sin ( phi_ )
<a name="l00123"></a>00123 
<a name="l00124"></a>00124     f_rpz_tmp3  = density / ( ( 2.0 * !pi ) ^ 3.0/2.0 * sigma^3 ) $
<a name="l00125"></a>00125     * exp ( -1.0 * ( ( vX__ - uXX )^2 / ( 2.0 * sigma^2 ) + $
<a name="l00126"></a>00126                         ( vY__ - uYY )^2 / ( 2.0 * sigma^2 ) + $
<a name="l00127"></a>00127                         ( vZ_ - uZZ )^2 / ( 2.0 * sigma^2 ) ) ) 
<a name="l00128"></a>00128     f_rpz_tmp3  = total ( f_rpz_tmp3, 3 ) * abs ( phi_[0,0,0] - phi_[0,0,1] )
<a name="l00129"></a>00129 
<a name="l00130"></a>00130     dummy = max ( f_vv_tmp[*,npar/2], iiMax )
<a name="l00131"></a>00131     print, uPer_p * vPer[iiMax,npar/2,0]/sigma^2
<a name="l00132"></a>00132     print, phiR     
<a name="l00133"></a>00133     f_rpz_int2  = f_rpz_int2 + f_rpz_tmp2 
<a name="l00134"></a>00134     f_vv_int    = f_vv_int + f_vv_tmp 
<a name="l00135"></a>00135     f_rpz_int   = f_rpz_int + f_rpz_tmp 
<a name="l00136"></a>00136     plot, f_vv_tmp[*,npar/2], psym = -4
<a name="l00137"></a>00137     oPlot, f_rpz_tmp3[*,npar/2]
<a name="l00138"></a>00138     stop
<a name="l00139"></a>00139 
<a name="l00140"></a>00140 endfor
<a name="l00141"></a>00141 
<a name="l00142"></a>00142 
<a name="l00143"></a>00143 ;    Build a vPer/vPar function
<a name="l00144"></a>00144 
<a name="l00145"></a>00145 ;f_vv   = density / ( ( 2.0 * !pi ) ^ 3.0/2.0 * sigma^3 ) $
<a name="l00146"></a>00146 ;   * exp ( ( -uPer^2 - (uPar-vPar[*,*,0])^2-vPer[*,*,0]^2 ) / ( 2.0 * sigma^2 ) ) $
<a name="l00147"></a>00147 ;                        * beselI (  uPer * vPer[*,*,0]/sigma^2, 0.0, /<span class="keywordtype">double</span> )
<a name="l00148"></a>00148 ;
<a name="l00149"></a>00149 ;f_vv2  = density / ( ( 2.0 * !pi ) ^ 3.0/2.0 * sigma^3 ) $
<a name="l00150"></a>00150 ;   * exp ( ( -uPer2^2 - (uPar-vPar[*,*,0])^2-vPer[*,*,0]^2 ) / ( 2.0 * sigma^2 ) ) $
<a name="l00151"></a>00151 ;                        * beselI ( uPer2 * vPer[*,*,0]/sigma^2, 0.0, /<span class="keywordtype">double</span> )
<a name="l00152"></a>00152 
<a name="l00153"></a>00153 
<a name="l00154"></a>00154 ;f_rpz  = f_rpz * dvPer * dvPar * dPhi * vPer
<a name="l00155"></a>00155 
<a name="l00156"></a>00156 ;   Build in cartesian
<a name="l00157"></a>00157 
<a name="l00158"></a>00158 nX  = 128 
<a name="l00159"></a>00159 nY  = 128 
<a name="l00160"></a>00160 nZ  = 128 
<a name="l00161"></a>00161 
<a name="l00162"></a>00162 xRange = 0.01*c
<a name="l00163"></a>00163 yRange = 0.01*c
<a name="l00164"></a>00164 zRange = 0.01*c
<a name="l00165"></a>00165 
<a name="l00166"></a>00166 vX  = transpose ( rebin ( (dIndGen ( nX + 1 )- nX / 2d0) / (nX/2d0) * xRange, nX+1, nY+1, nZ+1 ), [0,1,2] )
<a name="l00167"></a>00167 vY  = transpose ( rebin ( (dIndGen ( nY + 1 )- nY / 2d0) / (nY/2d0) * yRange, nY+1, nX+1, nZ+1 ), [1,0,2] )
<a name="l00168"></a>00168 vZ  = transpose ( rebin ( (dIndGen ( nZ + 1 )- nZ / 2d0) / (nZ/2d0) * zRange, nZ+1, nX+1, nY+1 ), [2,1,0] )
<a name="l00169"></a>00169 
<a name="l00170"></a>00170 f_xyz   = density / ( ( 2.0 * !pi ) ^ 3.0/2.0 * sigma^3 ) $
<a name="l00171"></a>00171     * exp ( -1.0 * ( ( vX - uX )^2 / ( 2d0 * sigma^2 ) + $
<a name="l00172"></a>00172                         ( vY - uY )^2 / ( 2d0 * sigma^2 ) + $
<a name="l00173"></a>00173                         ( vZ - uZ )^2 / ( 2d0 * sigma^2 ) ) )
<a name="l00174"></a>00174 
<a name="l00175"></a>00175 dX  = abs ( vX[0,0,0] - vX[1,0,0] )
<a name="l00176"></a>00176 dY  = abs ( vY[0,0,0] - vY[0,1,0] )
<a name="l00177"></a>00177 dZ  = abs ( vZ[0,0,0] - vZ[0,0,1] )
<a name="l00178"></a>00178 
<a name="l00179"></a>00179 ;f_xyz  = f_xyz * dx * dz * dy
<a name="l00180"></a>00180 
<a name="l00181"></a>00181 !p.multi = [0,3,2]
<a name="l00182"></a>00182 !p.charsize = 2.0
<a name="l00183"></a>00183 window, 0, xSize = 900, ySize = 600
<a name="l00184"></a>00184 contour, transpose ( f_rpz[*,*,0] ), vPar(0,*,0), vPer(*,0,0), $
<a name="l00185"></a>00185     levels = 10.0^fIndGen(12)*1e-14
<a name="l00186"></a>00186 plot, vper[*,0,0],total(f_rpz[*,nPer/2.0,*],3),psym=-4
<a name="l00187"></a>00187 oplot, vper[*,0,0],total(f_rpz2[*,nPer/2.0,*],3),psym=-4
<a name="l00188"></a>00188 
<a name="l00189"></a>00189 contour, transpose ( f_vv_int[*,*] ), vPar(0,*,0), vPer(*,0,0), $
<a name="l00190"></a>00190     levels = 10.0^fIndGen(18)*1e-10
<a name="l00191"></a>00191 plot, vper[*,0,0],(total(f_rpz_int,3))[*,nPer/2.0] * dPhi
<a name="l00192"></a>00192 oplot, vper[*,0,0],(total(f_rpz_int2,3))[*,nPer/2.0] * dPhi
<a name="l00193"></a>00193 oplot, vper[*,0,0],f_vv_int[*,nPer/2.0], thick = 2.0
<a name="l00194"></a>00194 ;plot, vper[*,0,0],total(f_vv_int,2)
<a name="l00195"></a>00195 
<a name="l00196"></a>00196 a1  = total ( (total(f_rpz_int3,3))[1:*,nPer/2.0] / vPer[1:*,0,0] )
<a name="l00197"></a>00197 a2  = total ( (total(f_rpz_int2,3))[*,nPer/2.0] ) 
<a name="l00198"></a>00198 oplot, vper[*,0,0],(total(f_rpz_int3,3))[*,nPer/2.0] / vPer[*,0,0] / a1 * a2
<a name="l00199"></a>00199 
<a name="l00200"></a>00200 contour, total(f_xyz,3), vX[*,0,0], vY[0,*,0], levels = 10.0^fIndGen(12)*1e-14
<a name="l00201"></a>00201 plot, vX[*,0,0], f_xyz[*,nY/2,nZ/2], psym=-4
<a name="l00202"></a>00202 
<a name="l00203"></a>00203 ;   Try fancy integration
<a name="l00204"></a>00204 
<a name="l00205"></a>00205 tmp1d   = fltArr ( nPer )
<a name="l00206"></a>00206 for i = 0, nPer - 1 do begin
<a name="l00207"></a>00207     tmp2d   = fltArr ( nPer, nPar+1 )
<a name="l00208"></a>00208     for j = 0, nPar +1 - 1 do begin
<a name="l00209"></a>00209 
<a name="l00210"></a>00210         tmp2d[i,j]  = int_tabulated ( reform(phi[0,0,*]), reform(f_rpz[i,j,*]) )
<a name="l00211"></a>00211 
<a name="l00212"></a>00212     endfor
<a name="l00213"></a>00213     tmp1d[i]    = int_tabulated ( reform(vPar[0,*,0]), reform(tmp2d[i,*]) )
<a name="l00214"></a>00214 endfor
<a name="l00215"></a>00215 int_rpz = int_tabulated ( reform(vPer[*,0,0]), tmp1d * vPer )
<a name="l00216"></a>00216 
<a name="l00217"></a>00217 
<a name="l00218"></a>00218 tmp1d   = fltArr ( nPer )
<a name="l00219"></a>00219 for i = 0, nPer - 1 do begin
<a name="l00220"></a>00220     tmp2d   = fltArr ( nPer, nPar+1 )
<a name="l00221"></a>00221     for j = 0, nPar +1 - 1 do begin
<a name="l00222"></a>00222 
<a name="l00223"></a>00223         tmp2d[i,j]  = int_tabulated ( reform(phi[0,0,*]), reform(f_rpz2[i,j,*]) )
<a name="l00224"></a>00224 
<a name="l00225"></a>00225     endfor
<a name="l00226"></a>00226     tmp1d[i]    = int_tabulated ( reform(vPar[0,*,0]), reform(tmp2d[i,*]) )
<a name="l00227"></a>00227 endfor
<a name="l00228"></a>00228 int_rpz2    = int_tabulated ( reform(vPer[*,0,0]), tmp1d * vPer )
<a name="l00229"></a>00229 
<a name="l00230"></a>00230 
<a name="l00231"></a>00231 tmp1d   = fltArr ( nX+1 )
<a name="l00232"></a>00232 for i = 0, nX +1- 1 do begin
<a name="l00233"></a>00233     tmp2d   = fltArr ( nX+1, nY+1 )
<a name="l00234"></a>00234     for j = 0, nY +1- 1 do begin
<a name="l00235"></a>00235 
<a name="l00236"></a>00236         tmp2d[i,j]  = int_tabulated ( reform(vZ[0,0,*]), reform(f_xyz[i,j,*]) )
<a name="l00237"></a>00237 
<a name="l00238"></a>00238     endfor
<a name="l00239"></a>00239     tmp1d[i]    = int_tabulated ( reform(vY[0,*,0]), reform(tmp2d[i,*]) )
<a name="l00240"></a>00240 endfor
<a name="l00241"></a>00241 int_xyz = int_tabulated ( reform(vX[*,0,0]), tmp1d )
<a name="l00242"></a>00242 
<a name="l00243"></a>00243 print, int_xyz, int_rpz, int_rpz2
<a name="l00244"></a>00244 print, total(f_xyz*dX*dY*dZ),total(f_rpz*dvPer*dvPar*dPhi*vPer)
<a name="l00245"></a>00245 print, abs(int_xyz-int_rpz)/int_xyz*100
<a name="l00246"></a>00246 
<a name="l00247"></a>00247 stop
<a name="l00248"></a>00248 
<a name="l00249"></a>00249 end
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri May 1 15:09:31 2009 for p2f by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.9 </small></address>
</body>
</html>
