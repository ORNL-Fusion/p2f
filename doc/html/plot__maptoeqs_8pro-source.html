<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>p2f: idl/plot_maptoeqs.pro Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Modules</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_9b564d76ac44037fc45a94b78ae21028.html">idl</a>
  </div>
</div>
<div class="contents">
<h1>plot_maptoeqs.pro</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 pro plot_maptoeqs, psiIn, thetaIn, rOut, zOut, eqdsk, fileName, $
<a name="l00002"></a>00002     rz2pt = rz2pt, $ ; keyword <span class="keywordflow">for</span> going from rOut/zOut -&gt; psiIn/thetaIn
<a name="l00003"></a>00003     rIn = rIn, $
<a name="l00004"></a>00004     zIn = zIn
<a name="l00005"></a>00005 
<a name="l00006"></a>00006     openr, unit, fileName, /get_lun
<a name="l00007"></a>00007 
<a name="l00008"></a>00008     readf, unit, nPsi, nTheta
<a name="l00009"></a>00009     readf, unit, xmac, rrc
<a name="l00010"></a>00010     readf, unit, n,m,l
<a name="l00011"></a>00011 
<a name="l00012"></a>00012     xFit_p  = fltArr ( nPsi )
<a name="l00013"></a>00013     readf, unit, xFit_p
<a name="l00014"></a>00014 
<a name="l00015"></a>00015     qValCh_p    = fltArr ( nPsi )
<a name="l00016"></a>00016     readf, unit, qValCh_p
<a name="l00017"></a>00017     
<a name="l00018"></a>00018     xFit_g  = fltArr ( nPsi )
<a name="l00019"></a>00019     readf, unit, xFit_g
<a name="l00020"></a>00020 
<a name="l00021"></a>00021     ;psiVal = fltArr ( nPsi )
<a name="l00022"></a>00022     ;readf, unit, psiVal 
<a name="l00023"></a>00023 
<a name="l00024"></a>00024     xFit_psiVal = fltArr ( nPsi )
<a name="l00025"></a>00025     readf, unit, xFit_psiVal
<a name="l00026"></a>00026 
<a name="l00027"></a>00027     x   = fltArr ( nPsi, nTheta+5 )
<a name="l00028"></a>00028     readf, unit, x
<a name="l00029"></a>00029 
<a name="l00030"></a>00030     z   = fltArr ( nPsi, nTheta+5 )
<a name="l00031"></a>00031     readf, unit, z
<a name="l00032"></a>00032 
<a name="l00033"></a>00033     grPsSq  = fltArr ( nPsi, nTheta+5 )
<a name="l00034"></a>00034     readf, unit, grPsSq 
<a name="l00035"></a>00035 
<a name="l00036"></a>00036     xJacob  = fltArr ( nPsi, nTheta+5 )
<a name="l00037"></a>00037     readf, unit, xJacob 
<a name="l00038"></a>00038 
<a name="l00039"></a>00039     readf, unit, bNorm, xNorm
<a name="l00040"></a>00040 
<a name="l00041"></a>00041     free_lun, unit
<a name="l00042"></a>00042 
<a name="l00043"></a>00043     print, nPsi, nTheta
<a name="l00044"></a>00044     print, xmac, rrc
<a name="l00045"></a>00045     print, n, m, l
<a name="l00046"></a>00046     print, bNorm, xNorm
<a name="l00047"></a>00047 
<a name="l00048"></a>00048     !p.multi = [0,2,3]
<a name="l00049"></a>00049     !p.charSize = 2.0
<a name="l00050"></a>00050     plot, xFit_p, title='xFit_p'
<a name="l00051"></a>00051     plot, qvalCh_p, title='qValCh_p'
<a name="l00052"></a>00052     plot, xFit_g, title='xFit_g'
<a name="l00053"></a>00053     ;plot, psiVal, title='psiVal'
<a name="l00054"></a>00054     plot, xFit_psiVal, title='xFit_psiVal'
<a name="l00055"></a>00055 
<a name="l00056"></a>00056     ;psiRange   = eqdsk.siBry - eqdsk.siMag
<a name="l00057"></a>00057     ;psiMin = eqdsk.siMag
<a name="l00058"></a>00058 
<a name="l00059"></a>00059     psiHalf = 1.0 / nPsi / 2.0
<a name="l00060"></a>00060     psiMin  = psiHalf
<a name="l00061"></a>00061     psiRange    = 1.0 - 2.0*psiHalf
<a name="l00062"></a>00062 
<a name="l00063"></a>00063     ;psiMin = 0.0
<a name="l00064"></a>00064     ;psiRange = 1.0
<a name="l00065"></a>00065 
<a name="l00066"></a>00066     psiVal  = fIndGen ( nPsi ) * ( psiHalf * 2.0 ) + psiHalf
<a name="l00067"></a>00067     theta   = fIndGen ( nTheta+5 ) / (nTheta) * 2.0 * !pi
<a name="l00068"></a>00068 
<a name="l00069"></a>00069     ;psiI   = ( psiIn - (psiMin+psiHalf) ) / (psiRange+psiHalf*2.0) * nPsi
<a name="l00070"></a>00070 
<a name="l00071"></a>00071 if keyword_set ( rz2pt ) then begin
<a name="l00072"></a>00072 
<a name="l00073"></a>00073 ;   Search for closest R/z point in the 2D interpolation
<a name="l00074"></a>00074 ;   meshes we have and use that.
<a name="l00075"></a>00075     
<a name="l00076"></a>00076     psiIn   = fltArr ( n_elements ( rIn ) )
<a name="l00077"></a>00077     thetaIn = fltArr ( n_elements ( rIn ) )
<a name="l00078"></a>00078 
<a name="l00079"></a>00079     for i = 0L, n_elements ( rIn ) - 1 do begin
<a name="l00080"></a>00080 
<a name="l00081"></a>00081         if ( i mod 1000 ) eq 0 then print, i
<a name="l00082"></a>00082 
<a name="l00083"></a>00083         rDiff   = rIn[i]/xmac - x
<a name="l00084"></a>00084         zDiff   = zIn[i]/rrc - z
<a name="l00085"></a>00085     
<a name="l00086"></a>00086         distance    = sqrt ( rDiff^2 + zDiff^2 )
<a name="l00087"></a>00087         
<a name="l00088"></a>00088         iiUse   = where ( distance eq min ( distance ), iiUseCnt )
<a name="l00089"></a>00089         if iiUseCnt ge 1 then begin
<a name="l00090"></a>00090     
<a name="l00091"></a>00091             arrayIndex  = array_indices ( x, iiUse[0] )
<a name="l00092"></a>00092             ;psiIn[i]   = xFit_psiVal[arrayIndex[0]]
<a name="l00093"></a>00093             psiIn[i]    = 0.5 / nPsi + arrayIndex[0] / (nPsi-1) * ( 1.0 - 1.0 / nPsi )
<a name="l00094"></a>00094             thetaIn[i]  = theta[arrayIndex[1]]
<a name="l00095"></a>00095         
<a name="l00096"></a>00096         endif else begin
<a name="l00097"></a>00097 
<a name="l00098"></a>00098             stop
<a name="l00099"></a>00099         
<a name="l00100"></a>00100         endelse
<a name="l00101"></a>00101 
<a name="l00102"></a>00102     endfor
<a name="l00103"></a>00103 
<a name="l00104"></a>00104 endif 
<a name="l00105"></a>00105 
<a name="l00106"></a>00106 ;   Interpolate from given psi, theta coords to 
<a name="l00107"></a>00107 ;   R,z coords
<a name="l00108"></a>00108 
<a name="l00109"></a>00109     psiI    = ( psiIn - (psiMin) ) / (psiRange) * nPsi
<a name="l00110"></a>00110     thetaJ  = thetaIn / ( 2.0 * !pi ) * (nTheta)
<a name="l00111"></a>00111 
<a name="l00112"></a>00112     rOut    = interpolate ( x, psiI, thetaJ )
<a name="l00113"></a>00113     zOut    = interpolate ( z, psiI, thetaJ )
<a name="l00114"></a>00114     rzJacob = interpolate ( xJacob, psiI, thetaJ )
<a name="l00115"></a>00115 
<a name="l00116"></a>00116     ;iiNearCore = where ( psiI lt 0, iiNCCnt )
<a name="l00117"></a>00117     ;if iiNCCnt gt 0 then begin
<a name="l00118"></a>00118 
<a name="l00119"></a>00119     ;   for i = 0L, iiNCCnt - 1 do begin
<a name="l00120"></a>00120 
<a name="l00121"></a>00121     ;       coeffs  = poly_fit ( psiVal[0:10], x[0:10,thetaJ[iiNearCore[i]]], 5 )
<a name="l00122"></a>00122     ;       rOut[iiNearCore[i]] = coeffs[0] + $
<a name="l00123"></a>00123     ;                               coeffs[1] * psiIn[iiNearCore[i]] + $
<a name="l00124"></a>00124     ;                               coeffs[2] * psiIn[iiNearCore[i]]^2 + $
<a name="l00125"></a>00125     ;                               coeffs[3] * psiIn[iiNearCore[i]]^3 + $
<a name="l00126"></a>00126     ;                               coeffs[4] * psiIn[iiNearCore[i]]^4 + $
<a name="l00127"></a>00127     ;                               coeffs[5] * psiIn[iiNearCore[i]]^5
<a name="l00128"></a>00128     ;
<a name="l00129"></a>00129     ;       coeffs  = poly_fit ( psiVal[0:10], z[0:10,thetaJ[iiNearCore[i]]], 5 )
<a name="l00130"></a>00130     ;       zOut[iiNearCore[i]] = coeffs[0] + $
<a name="l00131"></a>00131     ;                               coeffs[1] * psiIn[iiNearCore[i]] + $
<a name="l00132"></a>00132     ;                               coeffs[2] * psiIn[iiNearCore[i]]^2 + $
<a name="l00133"></a>00133     ;                               coeffs[3] * psiIn[iiNearCore[i]]^3 + $
<a name="l00134"></a>00134     ;                               coeffs[4] * psiIn[iiNearCore[i]]^4 + $
<a name="l00135"></a>00135     ;                               coeffs[5] * psiIn[iiNearCore[i]]^5
<a name="l00136"></a>00136 
<a name="l00137"></a>00137     ;   endFor
<a name="l00138"></a>00138 
<a name="l00139"></a>00139     ;endIf
<a name="l00140"></a>00140 
<a name="l00141"></a>00141     rOut    = rOut * xmac
<a name="l00142"></a>00142     zOut    = zOut * rrc
<a name="l00143"></a>00143 
<a name="l00144"></a>00144 end
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri May 1 14:49:23 2009 for p2f by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.7.1 </small></address>
</body>
</html>
